<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Aid Flow Sankey: Enhanced Insights</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>

<style>
  body {
    font-family: 'Avenir', 'Avenir Next', sans-serif;
    margin: 0;
    padding: 0;
    /* ‰øùÊåÅÂéüÊúâÁöÑËÉåÊôØËÆæÂÆö */
    background: linear-gradient(135deg, #f5f7fa 0%, #e8eef5 100%);
    height: 100vh;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  /* --- Floating Insight Card --- */
  .info-card {
    position: absolute;
    top: 80px;
    right: 30px;
    width: 320px;
    max-height: calc(100vh - 120px);
    overflow-y: auto;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border: 1px solid #e0e0e0;
    border-radius: 12px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.12);
    padding: 20px;
    z-index: 100;
    pointer-events: auto;
    transition: opacity 0.2s;
    cursor: pointer;
  }

  .info-card.pinned {
    border: 2px solid #2563eb;
    box-shadow: 0 8px 24px rgba(37, 99, 235, 0.3);
  }

  .pin-indicator {
    position: absolute;
    top: 10px;
    right: 10px;
    font-size: 16px;
    opacity: 0;
    transition: opacity 0.2s;
  }

  .info-card.pinned .pin-indicator {
    opacity: 1;
  }

  .card-header {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: #888;
    margin-bottom: 12px;
    font-weight: 700;
  }

  .country-title {
    font-size: 18px;
    font-weight: 800;
    margin-bottom: 8px;
    color: #111;
    line-height: 1.3;
  }

  .metric-value {
    font-size: 24px;
    font-weight: 700;
    font-family: 'Avenir', 'Avenir Next', sans-serif;
    color: #2563eb;
    margin-bottom: 12px;
  }
  
  .metric-desc {
    font-size: 12px;
    color: #666;
    line-height: 1.4;
    margin-bottom: 8px;
  }

  .breakdown-section {
    margin-top: 16px;
    padding-top: 12px;
    border-top: 1px solid #e0e0e0;
  }

  .breakdown-title {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: #888;
    margin-bottom: 8px;
    font-weight: 600;
  }

  .breakdown-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
    font-size: 11px;
    border-bottom: 1px solid #f0f0f0;
  }

  .breakdown-item:last-child {
    border-bottom: none;
  }

  .breakdown-country {
    color: #444;
    font-weight: 500;
    flex: 1;
    padding-right: 8px;
  }

  .breakdown-amount {
    color: #666;
    font-family: 'Avenir', 'Avenir Next', sans-serif;
    font-size: 10px;
    white-space: nowrap;
  }

  /* --- Page Header (Modified to match index_2) --- */
  .page-header {
    position: absolute;
    top: 20px;
    left: 0;
    width: 100%;
    text-align: center;
    pointer-events: none;
  }
  
  /* H1 Style matched to Index 2 */
  h1 { 
    margin-bottom: 5px;
    font-weight: bold; /* Default usually */
    color: #000; 
    font-size: 2em; /* Browser default, approx 32px */
  }
  
  /* Subtitle Style matched to Index 2 */
  p.subtitle { 
    color: #666; 
    font-size: 1rem; /* Standard size */
    margin: 0 0 20px 0; 
  }

  /* --- Enhanced Legend --- */
  .legend-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 40px;
    margin-top: 14px;
    pointer-events: auto;
  }
  
  .legend-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 16px;
    background: rgba(255, 255, 255, 0.85);
    backdrop-filter: blur(8px);
    border-radius: 20px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    transition: all 0.3s ease;
  }
  
  .legend-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
  }
  
  .legend-gradient {
    width: 100px;
    height: 8px;
    border-radius: 4px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }
  
  .legend-label {
    font-size: 13px;
    font-weight: 600;
    color: #333;
  }

  /* --- D3 Elements --- */
  .chart-area {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: visible;
  }

  .chart-area svg {
    overflow: visible;
  }

  .link {
    transition: stroke-opacity 0.3s ease;
    cursor: pointer;
  }
  
  .node rect {
    transition: all 0.3s ease;
    cursor: pointer;
    shape-rendering: geometricPrecision;
  }
  
  .node rect:hover {
    filter: drop-shadow(0px 4px 12px rgba(0, 0, 0, 0.3)) brightness(1.1);
    transform: translateX(2px);
  }
  
  .node text {
    font-size: 11px;
    font-weight: 600; 
    pointer-events: none;
    fill: #2a2a2a;
    text-shadow: 0 1px 2px rgba(255,255,255,0.95), 0 0 8px rgba(255,255,255,0.6);
  }
  
  .node-value-label {
    font-weight: 500;
    fill: #555;
    font-size: 10px;
  }

  .faded { opacity: 0.1 !important; }
  .link.faded { stroke-opacity: 0.05 !important; }

</style>
</head>
<body>

<div class="page-header">
  <h1>Global Aid Flow Analysis</h1>
  <p class="subtitle">Overview of the relationships between the top 20 donors and top 10 recipients.</p>
  
  <div class="legend-container">
    <div class="legend-item">
      <div class="legend-gradient" style="background: linear-gradient(to right, #0a2f51, #0d4a70, #1e6f8c, #2a9187, #52b2a3, #7dd3c0);"></div>
      <span class="legend-label">üí∞ Donors</span>
    </div>
    <div class="legend-item">
      <div class="legend-gradient" style="background: linear-gradient(to right, #c42a2a, #e94b3c, #f56b3f, #ff8c42, #ffab5e, #ffc971);"></div>
      <span class="legend-label">üéØ Recipients</span>
    </div>
  </div>
</div>

<div class="chart-area" id="chart"></div>

<div class="info-card" id="info-card">
  <span class="pin-indicator">üìå</span>
  <div class="card-header">DATA INSIGHTS</div>
  <div id="card-content">
    <div class="metric-desc" style="color:#aaa; font-style:italic;">
      Hover over any country or link to view detailed insights. Click to pin.
    </div>
  </div>
</div>

<script>
async function createVisualization() {
  // ... (JavaScript content is identical to the provided Index 1 file) ...
  const data = await d3.csv("AidDataCoreDonorRecipientYearPurpose_ResearchRelease_Level1_v3.1.csv", d => ({
    donor: d.donor,
    recipient: d.recipient,
    amount: +d.commitment_amount_usd_constant_sum
  }));

  const validData = data.filter(d => d.donor && d.recipient && d.amount > 0);

  const donorRollup = d3.rollup(validData, v => d3.sum(v, d => d.amount), d => d.donor);
  const topDonors = Array.from(donorRollup).sort((a, b) => b[1] - a[1]).slice(0, 20).map(d => d[0]);

  const recipientRollup = d3.rollup(validData, v => d3.sum(v, d => d.amount), d => d.recipient);
  const topRecipients = Array.from(recipientRollup).sort((a, b) => b[1] - a[1]).slice(0, 10).map(d => d[0]);

  const donorSet = new Set(topDonors);
  const recipientSet = new Set(topRecipients);

  const nodes = [];
  const nodeMap = new Map();

  topDonors.forEach((donor, i) => {
    const idx = nodes.length;
    nodes.push({ index: idx, name: donor, type: 'donor' });
    nodeMap.set(donor, idx);
  });
  topRecipients.forEach((recipient, i) => {
    const idx = nodes.length;
    nodes.push({ index: idx, name: recipient, type: 'recipient' });
    nodeMap.set(recipient, idx);
  });

  const links = [];
  const linkMap = new Map();
  validData.forEach(d => {
    if (donorSet.has(d.donor) && recipientSet.has(d.recipient)) {
      const key = d.donor + "|" + d.recipient;
      linkMap.set(key, (linkMap.get(key) || 0) + d.amount);
    }
  });
  
  linkMap.forEach((val, key) => {
    const [s, t] = key.split("|");
    links.push({
      source: nodeMap.get(s),
      target: nodeMap.get(t),
      value: val
    });
  });

  const donorBreakdown = new Map();
  topDonors.forEach(donor => {
    const breakdown = [];
    linkMap.forEach((amount, key) => {
      const [d, r] = key.split("|");
      if (d === donor && recipientSet.has(r)) {
        breakdown.push({ country: r, amount: amount });
      }
    });
    breakdown.sort((a, b) => b.amount - a.amount);
    donorBreakdown.set(donor, breakdown);
  });

  const recipientBreakdown = new Map();
  topRecipients.forEach(recipient => {
    const breakdown = [];
    linkMap.forEach((amount, key) => {
      const [d, r] = key.split("|");
      if (r === recipient && donorSet.has(d)) {
        breakdown.push({ country: d, amount: amount });
      }
    });
    breakdown.sort((a, b) => b.amount - a.amount);
    recipientBreakdown.set(recipient, breakdown);
  });

  const margin = { top: 120, right: 200, bottom: 40, left: 480 }; 
  const width = 1380 - margin.left - margin.right;
  const height = 800 - margin.top - margin.bottom;

  const svg = d3.select("#chart").append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

  const donorColorInterpolator = (t) => {
    const mappedT = 0.25 + t * 0.7;
    return d3.interpolateRgbBasis(["#0a2f51", "#0d4a70", "#1e6f8c", "#2a9187", "#52b2a3", "#7dd3c0"])(mappedT);
  };
  
  const recipientColorInterpolator = (t) => {
    const mappedT = 0.2 + t * 0.75;
    return d3.interpolateRgbBasis(["#c42a2a", "#e94b3c", "#f56b3f", "#ff8c42", "#ffab5e", "#ffc971"])(mappedT);
  };
  
  const donorColorScale = d3.scaleSequential().domain([0, topDonors.length - 1]).interpolator(donorColorInterpolator);
  const recipientColorScale = d3.scaleSequential().domain([0, topRecipients.length - 1]).interpolator(recipientColorInterpolator);

  const getColor = (node) => {
    if (node.type === "donor") {
      const index = topDonors.indexOf(node.name);
      return donorColorScale(index);
    }
    const index = topRecipients.indexOf(node.name);
    return recipientColorScale(index);
  };

  const sankey = d3.sankey()
      .nodeId(d => d.index)
      .nodeWidth(18)
      .nodePadding(18) 
      .extent([[1, 1], [width - 1, height - 6]])
      .nodeSort((a, b) => b.value - a.value);

  const { nodes: graphNodes, links: graphLinks } = sankey({
    nodes: nodes.map(d => Object.assign({}, d)),
    links: links.map(d => Object.assign({}, d))
  });

  const leftNodes = graphNodes.filter(n => n.type === 'donor');
  const maxLeftY = d3.max(leftNodes, d => d.y1);
  const minLeftY = d3.min(leftNodes, d => d.y0);
  const leftCenter = (maxLeftY + minLeftY) / 2;

  const rightNodes = graphNodes.filter(n => n.type === 'recipient');
  const maxRightY = d3.max(rightNodes, d => d.y1);
  const minRightY = d3.min(rightNodes, d => d.y0);
  const rightCenter = (maxRightY + minRightY) / 2;

  const yOffset = leftCenter - rightCenter;

  rightNodes.forEach(n => { n.y0 += yOffset; n.y1 += yOffset; });
  graphLinks.forEach(l => { l.y1 += yOffset; });

  const defs = svg.append("defs");
  
  const glowFilter = defs.append("filter").attr("id", "glow").attr("x", "-50%").attr("y", "-50%").attr("width", "200%").attr("height", "200%");
  glowFilter.append("feGaussianBlur").attr("stdDeviation", "2").attr("result", "coloredBlur");
  const feMerge = glowFilter.append("feMerge");
  feMerge.append("feMergeNode").attr("in", "coloredBlur");
  feMerge.append("feMergeNode").attr("in", "SourceGraphic");
  
  graphLinks.forEach((link, i) => {
    const gradientID = `gradient-${i}`;
    link.gradientID = gradientID;
    const gradient = defs.append("linearGradient")
        .attr("id", gradientID)
        .attr("gradientUnits", "userSpaceOnUse")
        .attr("x1", link.source.x1)
        .attr("x2", link.target.x0);
    
    const sourceColor = getColor(link.source);
    const targetColor = getColor(link.target);
    
    gradient.append("stop").attr("offset", "0%").attr("stop-color", sourceColor).attr("stop-opacity", 0.8);
    gradient.append("stop").attr("offset", "25%").attr("stop-color", d3.interpolateRgb(sourceColor, targetColor)(0.25)).attr("stop-opacity", 0.7);
    gradient.append("stop").attr("offset", "50%").attr("stop-color", d3.interpolateRgb(sourceColor, targetColor)(0.5)).attr("stop-opacity", 0.65);
    gradient.append("stop").attr("offset", "75%").attr("stop-color", d3.interpolateRgb(sourceColor, targetColor)(0.75)).attr("stop-opacity", 0.7);
    gradient.append("stop").attr("offset", "100%").attr("stop-color", targetColor).attr("stop-opacity", 0.8);
  });

  const linkPaths = svg.append("g").attr("fill", "none").attr("stroke-opacity", 0.5)
    .selectAll("path").data(graphLinks).join("path")
    .attr("class", "link")
    .attr("d", d3.sankeyLinkHorizontal())
    .attr("stroke-width", d => Math.max(1.5, d.width))
    .attr("stroke", d => `url(#${d.gradientID})`)
    .style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.1))")
    .on("mouseover", function(event, d) {
      d3.select(this).style("stroke-opacity", 0.95).style("filter", "url(#glow) drop-shadow(0 2px 4px rgba(0,0,0,0.2))");
      updateCardForLink(d);
    })
    .on("mouseout", function() {
      d3.select(this).style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.1))");
      resetCard();
    });

  const nodeGroup = svg.append("g").selectAll("g").data(graphNodes).join("g");

  nodeGroup.append("rect")
    .attr("class", "node")
    .attr("x", d => d.x0).attr("y", d => d.y0)
    .attr("height", d => d.y1 - d.y0).attr("width", d => d.x1 - d.x0)
    .attr("rx", 5)
    .attr("fill", d => getColor(d))
    .attr("stroke", d => d3.color(getColor(d)).darker(1))
    .attr("stroke-width", 2)
    .style("filter", "drop-shadow(0px 3px 6px rgba(0, 0, 0, 0.2))")
    .on("mouseover", (event, d) => { highlightNode(d); updateCardForNode(d); })
    .on("mouseout", () => { resetHighlight(); resetCard(); });

  const textGroup = nodeGroup.append("text")
    .attr("x", d => d.x0 < width / 2 ? -15 : d.x1 + 12)
    .attr("y", d => (d.y1 + d.y0) / 2)
    .attr("dy", "0.35em")
    .attr("text-anchor", d => d.x0 < width / 2 ? "end" : "start");

  textGroup.append("tspan").text(d => d.name);
  textGroup.append("tspan").attr("class", "node-value-label").attr("dx", "0.5em").text(d => `(${d3.format(".2s")(d.value).replace('G','B')})`);

  const cardContent = d3.select("#card-content");
  const infoCard = d3.select("#info-card");
  const defaultCardHtml = cardContent.html();
  let isPinned = false;

  infoCard.on("click", function(event) { event.stopPropagation(); isPinned = !isPinned; infoCard.classed("pinned", isPinned); });
  d3.select("body").on("click", function() { if (isPinned) { isPinned = false; infoCard.classed("pinned", false); } });

  function updateCardForNode(node) {
    const breakdown = node.type === 'donor' ? donorBreakdown.get(node.name) : recipientBreakdown.get(node.name);
    const role = node.type === 'donor' ? "Total Donated" : "Total Received";
    const detailTitle = node.type === 'donor' ? "Top Recipients" : "Top Donors";
    
    let breakdownHtml = '';
    if (breakdown && breakdown.length > 0) {
      breakdownHtml = `
        <div class="breakdown-section">
          <div class="breakdown-title">${detailTitle}</div>
          ${breakdown.map(item => `
            <div class="breakdown-item"><span class="breakdown-country">${item.country}</span><span class="breakdown-amount">$${d3.format(".2s")(item.amount).replace('G','B')}</span></div>
          `).join('')}
        </div>`;
    }

    const html = `
      <div style="width:40px; height:4px; background:${getColor(node)}; margin-bottom:10px; border-radius:2px;"></div>
      <div class="country-title">${node.name}</div>
      <div class="metric-value" style="color:${getColor(node)}">$${d3.format(",.2s")(node.value).replace('G','B')}</div>
      <div class="metric-desc">${role}</div>
      ${breakdownHtml}`;
    cardContent.html(html);
  }

  function updateCardForLink(link) {
    const html = `
      <div style="width:40px; height:4px; background:${getColor(link.source)}; margin-bottom:10px; border-radius:2px;"></div>
      <div class="country-title">${link.source.name} ‚Üí ${link.target.name}</div>
      <div class="metric-value" style="color:${getColor(link.source)}">$${d3.format(",.2s")(link.value).replace('G','B')}</div>
      <div class="metric-desc">Aid flow from ${link.source.name} to ${link.target.name}</div>`;
    cardContent.html(html);
  }

  function resetCard() { if (!isPinned) cardContent.html(defaultCardHtml); }

  function highlightNode(node) {
    const linkedLinks = new Set();
    const linkedNodes = new Set();
    linkedNodes.add(node.name);
    graphLinks.forEach(l => {
      if (l.source.name === node.name || l.target.name === node.name) {
        linkedLinks.add(l);
        linkedNodes.add(l.source.name);
        linkedNodes.add(l.target.name);
      }
    });
    linkPaths.classed("faded", true);
    nodeGroup.selectAll("rect").classed("faded", true);
    nodeGroup.selectAll("text").classed("faded", true);

    linkPaths.filter(d => linkedLinks.has(d)).classed("faded", false).style("stroke-opacity", 0.9);
    nodeGroup.filter(d => linkedNodes.has(d.name)).select("rect").classed("faded", false);
    nodeGroup.filter(d => linkedNodes.has(d.name)).select("text").classed("faded", false);
  }

  function resetHighlight() {
    linkPaths.classed("faded", false).style("stroke-opacity", null);
    nodeGroup.selectAll("rect").classed("faded", false);
    nodeGroup.selectAll("text").classed("faded", false);
  }
}
createVisualization();
</script>

</body>
</html>